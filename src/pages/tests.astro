---
import BaseLayout from '../layouts/BaseLayout.astro';
---

<BaseLayout title="Mes tests — AMBITIA" description="Visualisez et complétez vos tests de recrutement.">
  <section class="py-12 px-4">
    <div class="max-w-2xl mx-auto">
      <!-- Loading -->
      <div id="loading" class="text-center py-16">
        <span class="loading loading-spinner loading-lg text-primary"></span>
      </div>

      <!-- Content -->
      <div id="tests-content" class="hidden">
        <h1 class="text-3xl font-bold text-base-content mb-2">Mes tests</h1>
        <p class="text-base-content/60 mb-8">Complétez les tests ci-dessous pour avancer dans votre candidature.</p>

        <div id="tests-list" class="space-y-4">
          <!-- Populated by JS -->
        </div>

        <div id="no-app" class="text-center py-16 hidden">
          <p class="text-base-content/50">Aucune candidature active trouvée.</p>
          <a href="/jobs" class="btn btn-primary mt-4">Voir les postes</a>
        </div>

        <a href="/dashboard" class="btn btn-ghost btn-sm mt-8 gap-1">
          <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" aria-hidden="true">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
          </svg>
          Retour au tableau de bord
        </a>
      </div>
    </div>
  </section>
</BaseLayout>

<script>
  import { createClient } from '@supabase/supabase-js';

  const supabase = createClient(
    import.meta.env.PUBLIC_SUPABASE_URL,
    import.meta.env.PUBLIC_SUPABASE_ANON_KEY
  );

  const loadingDiv = document.getElementById('loading') as HTMLDivElement;
  const testsContent = document.getElementById('tests-content') as HTMLDivElement;
  const testsList = document.getElementById('tests-list') as HTMLDivElement;
  const noAppDiv = document.getElementById('no-app') as HTMLDivElement;

  // Hardcoded fallback tests (backward compatibility for jobs without job_tests rows)
  const fallbackTests = [
    { slug: 'big_five', label: 'Test de personnalite (Big Five)', url: '/test/bigfive', duration: '~15 min', weight: 0.30 },
    { slug: 'intelligence', label: 'Test de raisonnement logique', url: '/test/intelligence', duration: '~15 min', weight: 0.25 },
    { slug: 'quiz', label: 'Quiz connaissances produit', url: '/test/quiz', duration: '~10 min', weight: 0.20 },
    { slug: 'roleplay', label: 'Roleplay vocal (Simulation d\'appel)', url: '/test/roleplay', duration: '~15 min', weight: 0.25, requiresStatus: 'interview' },
  ];

  interface PipelineTest {
    slug: string;
    label: string;
    url: string;
    duration: string;
    weight: number;
    requiresStatus?: string;
    threshold?: number;
  }

  async function init() {
    const { data: { session } } = await supabase.auth.getSession();
    if (!session) { window.location.href = '/login'; return; }

    // Get latest application
    const { data: applications } = await supabase
      .from('applications')
      .select('id, status, job_id')
      .eq('user_id', session.user.id)
      .order('created_at', { ascending: false })
      .limit(1);

    loadingDiv.classList.add('hidden');
    testsContent.classList.remove('hidden');

    if (!applications || applications.length === 0) {
      noAppDiv.classList.remove('hidden');
      return;
    }

    const app = applications[0];

    // Try to load dynamic pipeline from job_tests + test_definitions
    let pipeline: PipelineTest[] = [];
    const { data: jobTests } = await supabase
      .from('job_tests')
      .select('*, test_definitions(slug, label, url_template, duration_label)')
      .eq('job_id', app.job_id)
      .order('sort_order', { ascending: true });

    if (jobTests && jobTests.length > 0) {
      // Dynamic pipeline from DB
      pipeline = jobTests.map((jt: any) => ({
        slug: jt.test_definitions.slug,
        label: jt.test_definitions.label,
        url: jt.test_definitions.url_template,
        duration: jt.test_definitions.duration_label || '',
        weight: jt.weight,
        requiresStatus: jt.requires_status || undefined,
        threshold: jt.threshold ?? undefined,
      }));
    } else {
      // Fallback to hardcoded pipeline
      pipeline = fallbackTests;
    }

    // Get completed tests
    const { data: results } = await supabase
      .from('test_results')
      .select('test_type, score, completed_at')
      .eq('application_id', app.id);

    const completedMap = new Map<string, { score: number; completed_at: string }>();
    results?.forEach((r: any) => {
      if (r.completed_at) {
        completedMap.set(r.test_type, { score: r.score, completed_at: r.completed_at });
      }
    });

    // Filter tests visible for this application status
    const visibleTests = pipeline.filter(t => {
      if (t.requiresStatus && app.status !== t.requiresStatus) return false;
      return true;
    });

    // Check if base tests (those not requiring a specific status) are completed
    const baseTests = pipeline.filter(t => !t.requiresStatus);
    const baseCompleted = baseTests.every(t => completedMap.has(t.slug));

    // Update application status if base tests done and status is pending/testing
    if (baseCompleted && (app.status === 'pending' || app.status === 'testing')) {
      // Calculate composite score using dynamic weights
      const { data: appData } = await supabase
        .from('applications')
        .select('knockout_answers')
        .eq('id', app.id)
        .single();

      let profileScore = 50;
      if (appData?.knockout_answers) {
        const ka = appData.knockout_answers as Record<string, string>;
        let pts = 0;
        if (ka.availability === 'yes') pts += 10;
        if (ka.internet === 'yes') pts += 10;
        const frenchMap: Record<string, number> = { native: 10, fluent: 7, intermediate: 3, beginner: 0 };
        pts += frenchMap[ka.french_level] ?? 5;
        const expMap: Record<string, number> = { yes_2: 10, yes_1: 7, yes_less_1: 3, none: 0 };
        pts += expMap[ka.call_experience] ?? 5;
        profileScore = Math.round((pts / 40) * 100);
      }

      if (!completedMap.has('composite')) {
        // Build breakdown from dynamic pipeline
        const breakdown: Record<string, number> = { profile: profileScore };
        let totalWeight = 0.25; // Profile weight
        let weightedSum = profileScore * 0.25;

        for (const test of baseTests) {
          const result = completedMap.get(test.slug);
          if (result) {
            const score = Math.min(100, Math.round(result.score));
            breakdown[test.slug] = score;
            weightedSum += score * test.weight;
            totalWeight += test.weight;
          }
        }

        // Normalize weights
        const composite = totalWeight > 0 ? Math.round(weightedSum / totalWeight * (totalWeight / totalWeight)) : profileScore;
        const normalizedComposite = Math.round(weightedSum / totalWeight);

        // Save composite score with weights used
        await supabase.from('test_results').insert({
          application_id: app.id,
          test_type: 'composite',
          score: normalizedComposite,
          result_data: {
            ...breakdown,
            _weights: Object.fromEntries(baseTests.map(t => [t.slug, t.weight])),
          },
          completed_at: new Date().toISOString(),
        });

        // Auto-decision based on composite score
        if (normalizedComposite < 40) {
          await supabase.from('applications').update({ status: 'rejected' }).eq('id', app.id);
        } else {
          await supabase.from('applications').update({ status: 'review' }).eq('id', app.id);
        }
      } else if (!completedMap.has('composite')) {
        await supabase.from('applications').update({ status: 'review' }).eq('id', app.id);
      }
    } else if (!baseCompleted && app.status === 'pending') {
      await supabase
        .from('applications')
        .update({ status: 'testing' })
        .eq('id', app.id);
    }

    testsList.innerHTML = visibleTests.map(test => {
      const completed = completedMap.get(test.slug);
      if (completed) {
        const date = new Date(completed.completed_at).toLocaleDateString('fr-FR');
        return `
          <div class="card bg-base-200 shadow-sm">
            <div class="card-body flex-row items-center justify-between">
              <div>
                <h3 class="font-semibold text-base-content">${test.label}</h3>
                <p class="text-sm text-base-content/60">Complété le ${date}${completed.score != null ? ` — Score : ${completed.score}` : ''}</p>
              </div>
              <span class="badge badge-success">Terminé</span>
            </div>
          </div>
        `;
      }
      return `
        <div class="card bg-base-200 shadow-sm">
          <div class="card-body flex-row items-center justify-between">
            <div>
              <h3 class="font-semibold text-base-content">${test.label}</h3>
              <p class="text-sm text-base-content/60">Durée : ${test.duration}</p>
            </div>
            <a href="${test.url}?app=${app.id}" class="btn btn-primary btn-sm">Commencer</a>
          </div>
        </div>
      `;
    }).join('');
  }

  init();
</script>
